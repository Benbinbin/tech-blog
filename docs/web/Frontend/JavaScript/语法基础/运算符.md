---
tags:
  - javascript
---

# 运算符
JavaScript 支持多种运算符，且不同数据类型可支持的运算符和运算含义也不同。

* **运算元**：运算符应用的对象，也称参数。
* **一元运算符**：一个运算符对应只操作有一个运算元，如 unary negation 一元负号运算符  `-`
* **二元运算符**：一个运算符拥有两个运算元，如减号运算符 `-`

:bulb: 按位操作符是将其操作数当作最多为 32 位的比特序列（由0和1组成，而不是十进制、十六进制或八进制数值）进行操作，并返回标准的 JavaScript 数字，具体运算规则可查看 [按位操作符 - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) 文档。
## 运算符优先等级
如果一个表达式拥有超过一个运算符，执行的顺序则由优先级决定

JavaScript 中[每个运算符都有对应的优先级数字](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence)，数字越大越先执行，如果优先级相同，则按照由左至右的顺序执行。

:bulb: 要记住一元运算符优先级高于二元运算符

## 算术运算
JavaScript 控制台支持计算数字公式，常用的算术运算符

* 加法 `+`
* 减法 `-`
* 乘法 `*` :warning: 不是 `x`
* 除法 `/`（在 Java 中是整除）
* 乘方 `**` 即幂运算，对于运算元是非整数的情况依然适用，如 `a ** (1/2)` 相当于开方。 :warning: 日常数学公式中的乘方符号 `^` 在是指按位 `XOR`
* 取模 `%` modulo 即求余

## 比较运算
比较数值的比较运算符

| 运算符 |     含义     |
| -------- | ------------- |
| `<`    | 小于         |
| `>`    | 大于         |
| `<=`   | 小于或等于 |
| `>=`   | 大于或等于 |
| `==`   | 等于         |
| `!=`   | 不等于      |

数字之间的比较结果是布尔值 `true` 或 `false`，比较的结果可以被赋值给任意变量

:bulb: 当对**不同类型**的值进行比较时，JavaScript 会首先将其转化为数字 number 类型，再判定大小。

比较字符的大小时，JavaScript 会使用 Unicode 编码顺序进行判定，而对于字符串时是按从左往右依次比较字符（母）。

字符串的比较算法步骤：

1. 首先比较两个字符串的首位字符大小。
2. 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。
3. 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。
4. 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。
5. 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。

```js
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

`null` 和 `undefined` 比较行为很特别。

当使用**非严格相等 `==` 比较** `null` 空值和 `undefined` 未定义时，JavaScript 存在一个特殊的规则，会判定它们相等。

```js
alert( null == undefined ); // true
```

当使用数学式或其他比较方法 `<` `>` `<=` `>=`时（不包括 `==` 与 `!=`，由于相等性检测比较特殊，与其他比较运算符行为不一样）`null` 和 `undefined` 会被分别转化为数字 `0` 和 `NaN`

```js
// null 转换为 0
alert( null > 0 );   // false
alert( null >= 0 );   // true

// null 不转换为 0
alert( null == 0 );   // false

alert( undefined > 0 ); // false
alert( undefined < 0 ); // false
alert( undefined == 0 ); // false
```

:bulb: `undefined` 和 `null` 在相等性检测 `==` 或 `!=` 中不会进行任何的类型转换，且`undefined` 只与 `null` 相等，不会与其他值相等。

:warning: 由于比较不同类型的值时，处于判断符号 `==` 或 `!=` 两侧的值会先被转化为数字，隐式类型转换引起不可预料的结果。推荐使用[绝对比较运算符](D:/Front_end/JavaScript/数据类型.md#隐式类型转换)则比较时不会做任何的类型转换。

:warning: 由于 `null` 和 `undefined` 特殊的比较行为，对于取值可能是 `null` 或 `undefined` 的变量，请按需要分别检查它的取值情况。
## 字符串连接
二元运算符加号 `+` 被应用于字符串，将合并（连接）各个字符串。**只要其中一个运算元是字符串，那么另一个运算元也将被转化（数据隐式类型转换）为字符串**。

```js
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

:bulb: 如果想在连接的两个字符串之间留个空格，需要明确地在添加（使用引号把空格包括插在两者之间），解析器不会自动添加

:warning: 运算符运算方向根据运算符的不同优先级别而定，或同级别的运算符由左至右运算，因此如果是两个数字相加，后面再连接一个字符串，那么两个数字会先进行算术运算，再转化为字符串与其后的字符串连接

```js
"Hello" + 5*10   // "Hello50"
alert(2 + 2 + '1' );   // "41" 而不是 "221"
```

## 赋值运算符
赋值运算符将右侧的值「写入」左侧的变量，对于链式赋值也是由右向左执行。

:bulb: 每个运算符都有一个返回值，赋值符号返回左侧的值。

## 数字转换
一元运算符加号，即加号 `+` 应用于单个值，会将其转化为数字（对数字没有任何作用），相当于 `Number()` 函数。

## 逗号运算符
逗号运算符能让我们处理多个语句，使用 `,` 将它们分开，每个语句都运行了，但是只有最后的语句的结果会被返回。

```js
// 在 for 循环的条件判断中，一行上用逗号分隔了三个算式
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
```

## 自增和自减

* 自增：`x++` or `++x` 等同于 `x = x + 1`
* 自减：`x--` or `--x` 等同于 `x = x - 1`

:bulb: 自增/自减的优先级比绝大部分的算数运算符要高。
:bulb: 前置自增 `++x` 返回新值，即计算后再返回新值。后置自增 `x++`返回原来的值，即先返回原值再自增。它们一般只有在使用自增式子的返回值作为表达式一部分时才有区别，若只是需要自增 `x` 值则两种方式均可。因此如果我们想要对变量进行自增操作，并且需要立刻使用自增后的值，那么我们需要使用前置形式；如果我们想要将一个数加一，但是我们想使用其自增之前的值，那么我们需要使用后置形式。自减也是类似。

```js
// 前置自增
let counter = 1;
let a = ++counter;
alert(a);   // 2
alert(counter);   // 2

// 后置自增
let counter = 1;
let a = counter++;
alert(a);   // 1
alert(counter);   // 2
```

:warning: 自增/自减只能应用于变量

## 修改并替换
对一个变量进行操作，并把计算得到的新结果存储在原来的这个变量中，可以使用简写形式：

:bulb: 简短的“修改并替换”运算符对所有的运算符包括位运算符都有效，如 `/=`等等。

常用的简写形式

* 增加简写：`x += 3` 等同于 `x = x + 3`
* 减少简写 `x -= 6` 等同于 `x = x - 6`
* 相乘简写：`x *= 2` 等同于 `x = x * 2`
* 相除简写：`x /= 5` 等同于 `x = x / 5`

## 逻辑运算符
JavaScript 里有三个逻辑运算符：
* `||` 或，优先级别最低
* `&&`与，优先级别为中
* `!` 非，优先级别最高

:bulb: 逻辑表达式基于优先级别（默认）从左到右进行条件判断，可以用括号来更改运算的优先级别。

这些运算符操作布尔值组合并返回相应的布尔值作为结果。

| 逻辑运算符 |     含义     |           示例           |                                解释                                 |
| :-----------: | :-----------: | :-----------------------: | :------------------------------------------------------------------: |
|    `&&`     | 逻辑 `AND` | `value1 && value2` |  只有 `value1` 和 `value2` 都为 `true`，才返回 `true`   |
|    `||`     | 逻辑 `OR`  | `value1 || value2` | 只要 `value1` 或 `value2` 之一为 `true`，就返回 `true` |
|     `!`     | 逻辑 `NOT` |       `!value1`       |                     返回 `value1` 的相反值                      |

:bulb: 如果操作数不是布尔值，那么它将会被[隐式转化为布尔值](D:/Front_end/JavaScript/数据类型.md#类型转换)来参与运算。

### 或
**或运算 `||`** 是指参与运算的任意一个参数为 `true`，返回的结果就为 `true`，否则返回 `false`。

```js
// 或运算真值表，四种可能的逻辑组合
true || true;   // true
false || true;  // true
true || false;  // true
false || false; // false
```

也支持非布尔值（进行隐式类型转换）组合运算，并返回 `true` 相应的参数。

```js
if (1 || 0) { // 工作原理相当于 if( true || false )
  alert( 'truthy!' );   // 弹出一个模态窗口显示 truthy！
}
```

:bulb: 可以用于 if 语句中，用多个 `||` 并列串联不同的条件语句，构成复杂的判断情况

### 与
**与运算 `&&`** 是指当两个操作数都是真值才返回 `true`，否则返回 `false`。

```js
// 与运算真值表，四种可能的逻辑组合
true && true;   // true
false && true;  // false
true && false;  // false
false && false; // false
```

就像或运算一样，可以支持任意类型的值组合运算，并返回 `false` 相对应的参数。

### 短路
使用 `&&` 或 `||` 逻辑运算符时，出现的逻辑表达式的**后续参数不用考虑**的行为就叫做**最少运算**或**短路**，因为前面的参数已经满足条件了。

![`&&` 与 `||` 运算的真假值表](_v_images/20200318110428088_29411.png)

在特定的情况下，后一个条件 B 的布尔值不重要：
* 当第一个条件 A 布尔值为 `false` 时，那么无论第二个条件 B 的值是多少，`A && B` 整个表达式始终为 `false`，则在该情况下不须考虑条件 B 的情况。
* 当第一个条件 A 布尔值为 `true` 时，那么无论第二个条件 B 的值是多少，`A || B` 整个表达式始终为 `true`，则在该情况下不须考虑条件 B 的情况。

利用短路特性，可以实现**短路取值**，即通过一个逻辑链为变量赋予特定的值：
* 一个**或运算 `||`** 链，将返回第一个真值，如果没有真值就返回最后一个值。
* 一个**与运算 `&&`** 链，将返回第一个假值，如果没有假值就返回最后一个值。

```js
let currentUser = null;
let defaultUser = "John";

let name = currentUser || defaultUser || "unnamed";   // 返回第一个真值或最后一个值

alert( name );   // John
```

### 非
**非运算 `!`** 是指返回参数的相反的布尔值。

:bulb: 可以使用两个非运算 `!!` 来将某个值转化为布尔类型，类似于 `Boolean()` 函数