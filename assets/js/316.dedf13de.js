(window.webpackJsonp=window.webpackJsonp||[]).push([[316],{1413:function(t,e,r){"use strict";r.r(e);var o=r(18),n=Object(o.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"异步操作"}},[t._v("异步操作")]),t._v(" "),r("p",[t._v("代码通常时同步的，即语句依次按顺序执行，JavaScript 线程模型可以确保语句在一个时间轴上运行。异步代码则是不能保证会在一个不间断的时间轴上执行，如网络请求、一些API方法等未知完成使劲按的代码，均为异步操作。")]),t._v(" "),r("p",[t._v("针对异步代码 JavaScript 默认处理技术是使用回调函数，回调函数是将函数作为参数，传递给异步代码。在异步代码执行结束后，若达到某个条件就会调用该回调函数（告知用户异步操作完成或执行下一步操作）。但异步操作经常需要考虑操作失败的情况（如网络请求失败）；若回调函数也是一个异步操作时（会在回调函数中嵌套了其自身的回调函数），造成回调地狱 pyramid of doom 难以调试。在 ES6 中用 "),r("RouterLink",{attrs:{to:"/web/Frontend/JavaScript/语法基础/promise.html"}},[r("code",[t._v("Promise")]),t._v(" 对象")]),t._v(" 处理异步代码更方便。")],1)])}),[],!1,null,null,null);e.default=n.exports}}]);