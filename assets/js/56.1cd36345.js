(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{1139:function(t,s,v){"use strict";v.r(s);var _=v(18),n=Object(_.a)({},(function(){var t=this,s=t.$createElement,_=t._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"dfs和bfs"}},[t._v("DFS和BFS")]),t._v(" "),_("p",[t._v("搜索树和图有两种基本策略：")]),t._v(" "),_("ul",[_("li",[t._v("深度优先搜索 DFS，Deep First Search")]),t._v(" "),_("li",[t._v("广度优先搜索 BFS，Breath First Search")])]),t._v(" "),_("h2",{attrs:{id:"深度优先搜索"}},[t._v("深度优先搜索")]),t._v(" "),_("p",[t._v("贯彻了「不撞南墙不回头」的原则，只要没有碰壁就决不选择其它的道路，坚持向当前道路的深处挖掘（一直走到尾），常用于暴力搜索所有状态。深度优先搜索的核心思想是试图"),_("strong",[t._v("穷举")]),t._v("所有的完整路径，以找到可行的路径。")]),t._v(" "),_("p",[t._v("穷举法基本过程：")]),t._v(" "),_("ul",[_("li",[t._v("从入口位置为起点往前走")]),t._v(" "),_("li",[t._v("在前进的过程中可能遇到分支，只能选择其中的一条，然后继续前进（往后可能会不止一次遇到分支，每遇到一个新的分支，需要做一次选择）")]),t._v(" "),_("li",[t._v("选择的这条分支未必是一条通路，如果走到最后发现此路不通，那么你就要退回到离你最近的那个分叉路口")]),t._v(" "),_("li",[t._v("然后尝试看其它的分支能不能走通")]),t._v(" "),_("li",[t._v("如果当前的岔路口分叉出去的所有道路都走不通，那么就需要退回到当前岔路口的上一个岔路口，进一步去寻找新的路径")]),t._v(" "),_("li",[t._v("不断依次探寻分支，「最坏」的情况是穷举完所有分支，尝试到最后一种情况找到通路")])]),t._v(" "),_("p",[t._v("通过"),_("strong",[t._v("栈结构")]),t._v("和"),_("strong",[t._v("递归")]),t._v("编码实现深度优先搜索 DFS，因为在尝试分支岔路口时，会不断重复前进、后退的操作，其实和栈结构的入栈、出栈过程类似（后进先出），而二叉树的遍历一般使用递归来实现。")]),t._v(" "),_("p",[_("img",{attrs:{src:v(470),alt:"DFS"}})]),t._v(" "),_("p",[t._v("把迷宫中的每一个坐标看做是栈里的一个元素，用栈来模拟这个过程（依次从上到下尝试分支）：")]),t._v(" "),_("ol",[_("li",[t._v("从 "),_("code",[t._v("A")]),t._v(" 出发（"),_("code",[t._v("A")]),t._v("入栈），经过了"),_("code",[t._v("B")]),t._v("（"),_("code",[t._v("B")]),t._v("入栈），接下来面临 "),_("code",[t._v("C")]),t._v("、"),_("code",[t._v("D")]),t._v("、"),_("code",[t._v("E")]),t._v("三条路。这里按照从上到下的顺序来走（你也可以选择其它顺序），先走"),_("code",[t._v("C")]),t._v("（"),_("code",[t._v("C")]),t._v("入栈）。")]),t._v(" "),_("li",[t._v("发现 "),_("code",[t._v("C")]),t._v("是死胡同，后退到最近的岔路口 "),_("code",[t._v("B")]),t._v("（"),_("code",[t._v("C")]),t._v("出栈），尝试往"),_("code",[t._v("D")]),t._v("方向走（"),_("code",[t._v("D")]),t._v("入栈）。")]),t._v(" "),_("li",[t._v("发现"),_("code",[t._v("D")]),t._v(" 是死胡同，，后退到最近的岔路口 "),_("code",[t._v("B")]),t._v("（"),_("code",[t._v("D")]),t._v("出栈），尝试往"),_("code",[t._v("E")]),t._v("方向走（"),_("code",[t._v("E")]),t._v("入栈）。")]),t._v(" "),_("li",[_("code",[t._v("E")]),t._v(" 是一个岔路口，眼前有两个选择："),_("code",[t._v("F")]),t._v(" 和 "),_("code",[t._v("G")]),t._v("。按照从上到下的顺序来走，先走"),_("code",[t._v("F")]),t._v("（"),_("code",[t._v("F")]),t._v("入栈）。")]),t._v(" "),_("li",[t._v("发现"),_("code",[t._v("F")]),t._v(" 是死胡同，后退到最近的岔路口 "),_("code",[t._v("E")]),t._v("（"),_("code",[t._v("F")]),t._v("出栈），尝试往"),_("code",[t._v("G")]),t._v("方向走（"),_("code",[t._v("G")]),t._v("入栈）。")]),t._v(" "),_("li",[_("code",[t._v("G")]),t._v(" 是一个岔路口，眼前有两个选择："),_("code",[t._v("H")]),t._v(" 和 "),_("code",[t._v("I")]),t._v("。按照从上到下的顺序来走，先走"),_("code",[t._v("H")]),t._v("（"),_("code",[t._v("H")]),t._v("入栈）。")]),t._v(" "),_("li",[t._v("发现 "),_("code",[t._v("H")]),t._v(" 是死胡同，后退到最近的岔路口 "),_("code",[t._v("G")]),t._v("（"),_("code",[t._v("H")]),t._v("出栈），尝试往"),_("code",[t._v("I")]),t._v("方向走（"),_("code",[t._v("I")]),t._v("入栈）。")]),t._v(" "),_("li",[_("code",[t._v("I")]),t._v(" 就是出口，成功走出迷宫。")])]),t._v(" "),_("p",[t._v("最后栈里保留的元素依次是"),_("code",[t._v("A")]),t._v("、"),_("code",[t._v("B")]),t._v("、"),_("code",[t._v("E")]),t._v("、"),_("code",[t._v("G")]),t._v("、"),_("code",[t._v("I")]),t._v("，因此 "),_("code",[t._v("A")]),t._v("->"),_("code",[t._v("B")]),t._v("->"),_("code",[t._v("E")]),t._v("->"),_("code",[t._v("G")]),t._v("->"),_("code",[t._v("I")]),t._v(" 就是走出迷宫的路径。")]),t._v(" "),_("p",[t._v("实际上使用"),_("RouterLink",{attrs:{to:"/data/Algorithm/Frontend/二叉树遍历.html#先序遍历"}},[t._v("先序遍历")]),t._v("二叉树的所有结点就是 DFS 深度优先搜索思想的一种实现，可以说深度优先搜索过程就类似于树的先序遍历，是树的先序遍历的推广：")],1),t._v(" "),_("ul",[_("li",[t._v("从根结点出发，输出当前的结点内容，然后访问左侧的子结点（递归调用函数）")]),t._v(" "),_("li",[t._v("如果左子树同样存在左侧子结点，就头也不回地继续访问下去")]),t._v(" "),_("li",[t._v("一直到左侧子结点为空时，才退回到距离最近的父结点，再尝试去访问父结点的右侧子结点（递归调用函数）")])]),t._v(" "),_("p",[t._v("在这个递归函数中，递归式用来先后遍历左子树、右子树（分别探索不同的道路），递归边界是在识别到结点为空时会直接返回（撞到了南墙）。")]),t._v(" "),_("div",{staticClass:"language-js extra-class"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 先序遍历二叉树所有结点")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 入参是树的根结点对象")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("preorder")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("root")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归边界，root 为空")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("root"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 输出当前遍历的结点值")]),t._v("\n    console"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("'当前遍历的结点值是：'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" root"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归遍历左子树")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("preorder")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归遍历右子树")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("preorder")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),_("p",[t._v("在递归函数的底层就是用"),_("strong",[t._v("栈结构")]),t._v("来实现的，JS 会维护一个叫「函数调用栈」的东西，"),_("code",[t._v("preorder")]),t._v(" 每调用一次自己，相关调用的上下文就会被 "),_("code",[t._v("push")]),t._v(" 进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被 "),_("code",[t._v("pop")]),t._v(" 出来（函数被递归调用时，较深的调用层会先被计算返回，然后其上一层函数才可以继续执行，这和栈后进先出类似）。因此，即便二叉树的递归调用过程中，并没有出现栈这种数据结构，也依然改变不了递归的本质是栈的事实。")]),t._v(" "),_("h2",{attrs:{id:"广度优先搜索"}},[t._v("广度优先搜索")]),t._v(" "),_("p",[t._v("广度优先搜索 BFS 关心的是"),_("strong",[t._v("眼下自己能够直接到达的所有坐标")]),t._v("，其动作有点类似于「扫描」，经过一层层的结点扫描，找到可以通往下一层的入口，最后达到出口。")]),t._v(" "),_("p",[t._v("BFS 的遍历规则基本过程：")]),t._v(" "),_("ul",[_("li",[t._v("站在入口处（第一层），「扫描」下一层可以直接能抵达的岔路口")]),t._v(" "),_("li",[t._v("依次访问这些通路，记下哪些通路可以再到达下一层，记下这些结点")]),t._v(" "),_("li",[t._v("依次访问这些结点，看这些结点中哪些可以访问下一层，再记下可行的结点")]),t._v(" "),_("li",[t._v("重复「扫描」")]),t._v(" "),_("li",[t._v("直到最后到达出口")])]),t._v(" "),_("p",[t._v("在分层遍历的过程中有两个规律：")]),t._v(" "),_("ul",[_("li",[t._v("每访问完毕一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉。")]),t._v(" "),_("li",[t._v("站在某个确定坐标的位置上，我们所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们。")])]),t._v(" "),_("p",[_("img",{attrs:{src:v(471),alt:"BFS"}})]),t._v(" "),_("p",[t._v("丢弃已访问的坐标、记录新观察到的坐标，这个顺序符合「先进先出」的原则，因此可以使用"),_("strong",[t._v("队列结构")]),t._v("编码实现广度优先搜索 BFS。")]),t._v(" "),_("p",[t._v("用一个队列 "),_("code",[t._v("queue")]),t._v(" 模拟 BFS 过程：")]),t._v(" "),_("ol",[_("li",[t._v("初始化先将入口 "),_("code",[t._v("A")]),t._v(" 入队。")]),t._v(" "),_("li",[t._v("访问入口 "),_("code",[t._v("A")]),t._v(" 发现直接能抵达的坐标只有"),_("code",[t._v("B")]),t._v("，访问完毕后将"),_("code",[t._v("A")]),t._v("出队，将"),_("code",[t._v("B")]),t._v("入队。")]),t._v(" "),_("li",[t._v("访问 "),_("code",[t._v("B")]),t._v(" 发现直接能抵达的坐标变成了 "),_("code",[t._v("C")]),t._v("、"),_("code",[t._v("D")]),t._v(" 和 "),_("code",[t._v("E")]),t._v("，于是把这三个坐标记为下一层的访问对象，访问完毕后将"),_("code",[t._v("B")]),t._v("出队，将下一层结点全部入队")]),t._v(" "),_("li",[t._v("访问第三层，这里按照从上到下的顺序，先访问 "),_("code",[t._v("C")]),t._v("（访问完毕后 "),_("code",[t._v("C")]),t._v(" 出队）和 "),_("code",[t._v("D")]),t._v("（访问完毕后 "),_("code",[t._v("D")]),t._v(" 出队），然后访问 "),_("code",[t._v("E")]),t._v("（访问完毕后 "),_("code",[t._v("E")]),t._v(" 出队）。访问 "),_("code",[t._v("C")]),t._v(" 处和 "),_("code",[t._v("D")]),t._v(" 处都没有见到新的可以直接抵达的坐标，所以不做额外的动作。但是在 "),_("code",[t._v("E")]),t._v(" 处我们见到了可以直接抵达的 "),_("code",[t._v("F")]),t._v(" 和 "),_("code",[t._v("G")]),t._v("，因此把 "),_("code",[t._v("F")]),t._v(" 和 "),_("code",[t._v("G")]),t._v(" 记为下一层（第四层）需要访问的对象，"),_("code",[t._v("F")]),t._v("、"),_("code",[t._v("G")]),t._v("依次入队（"),_("code",[t._v("queue")]),t._v("里现在是 "),_("code",[t._v("F")]),t._v("、"),_("code",[t._v("G")]),t._v("）。")]),t._v(" "),_("li",[t._v("访问第五层。第五层按照从上到下的顺序，先访问的是 "),_("code",[t._v("H")]),t._v("（访问完毕后 "),_("code",[t._v("H")]),t._v(" 出队），发现从 "),_("code",[t._v("H")]),t._v(" 出发没有可以直接抵达的坐标，因此不作额外的操作。接着访问 "),_("code",[t._v("I")]),t._v("（访问完毕后 "),_("code",[t._v("I")]),t._v(" 出队），发现 "),_("code",[t._v("I")]),t._v(" 就是出口，问题得解（此时 "),_("code",[t._v("queue")]),t._v(" 队列已经被清空）。")])]),t._v(" "),_("p",[t._v("💡 在这个过程里循环往复地依次访问队列里已经有的坐标，将其出队；记录从当前坐标出发可直接抵达的所有坐标，将其入队（先进先出）。")]),t._v(" "),_("p",[t._v("实际上使用"),_("RouterLink",{attrs:{to:"/data/Algorithm/Frontend/二叉树遍历.html"}},[t._v("迭代遍历中的"),_("strong",[t._v("层次遍历")])]),t._v("二叉树的所有结点就是 BFS 广度优先搜索思想的一种实现，即按照从上到下的层次顺序，从左到右地遍历一个二叉树。")],1),t._v(" "),_("p",[_("img",{attrs:{src:v(472),alt:"层次遍历（红色数字即为遍历的序号）"}})]),t._v(" "),_("div",{staticClass:"language-js extra-class"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// BFS 伪代码")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token constant"}},[t._v("BFS")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("root")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" queue "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化队列queue")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 根结点首先入队")]),t._v("\n    queue"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 队列不为空，说明没有遍历完全")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("queue"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" top "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" queue"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 取出队头元素")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 访问 top")]),t._v("\n        console"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果左子树存在，左子树入队")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            queue"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果右子树存在，右子树入队")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            queue"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("top"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        queue"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("shift")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 访问完毕，队头元素出队")]),t._v("\n        "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 继续执行迭代，取出队列下一个队头元素")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=n.exports},470:function(t,s,v){t.exports=v.p+"assets/img/20200909120029738_22468.cef655e3.png"},471:function(t,s,v){t.exports=v.p+"assets/img/20200909130314218_21860.a3be2c54.png"},472:function(t,s,v){t.exports=v.p+"assets/img/20200909132439637_13022.d52d6d30.png"}}]);