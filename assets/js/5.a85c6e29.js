(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{1261:function(t,_,v){"use strict";v.r(_);var e=v(18),o=Object(e.a)({},(function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"git-基础"}},[t._v("Git 基础")]),t._v(" "),e("p",[t._v("参考："),e("a",{attrs:{href:"https://git-scm.com/book/zh/v2",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git Book"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("Git 是一个"),e("strong",[t._v("分布式")]),t._v("版本控制系统，其核心功能是"),e("strong",[t._v("追踪文件的变更")]),t._v("，即保留项目的详细"),e("strong",[t._v("历史记录")]),t._v("，并且能够在不同的版本上进行工作。保留详细的项目历史记录很重要，可以看出一段时间内项目的进度，如果需要还可以并恢复数据或文件，回到项目的某个阶段。")]),t._v(" "),e("p",[t._v("版本控制系统 version control system，简称 VCS，是一个管理源代码不同版本的工具，除了 Git 软件外还有其他版本控制系统，如 "),e("a",{attrs:{href:"https://subversion.apache.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Subversion"),e("OutboundLink")],1),t._v("、"),e("a",{attrs:{href:"https://www.mercurial-scm.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mercurial"),e("OutboundLink")],1),t._v(" 等。版本控制系统模型包括两大主要类型：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("集中式模型")]),t._v(" centralized version control systems, CVCS：所有用户都连接到一个中央的主仓库 "),e("code",[t._v("master repository")])]),t._v(" "),e("li",[e("strong",[t._v("分布式模型")]),t._v(" distributed version control systems, DVCS：每个用户都在自己的计算机上拥有完整的仓库")])]),t._v(" "),e("p",[t._v('💡 源代码管理器 source code manager，简称 SCM，是版本控制系统的另一个名称。Git 是一个 SCM（因此也是 VCS！）。Git 网站地址是 https://git-scm.com/ （它的域名中直接包含 "SCM"）。')]),t._v(" "),e("h2",{attrs:{id:"术语"}},[t._v("术语")]),t._v(" "),e("p",[t._v("参考："),e("a",{attrs:{href:v(725)}},[t._v("Git 关键术语")]),t._v(" | "),e("a",{attrs:{href:v(726)}},[t._v("英文版")])]),t._v(" "),e("h3",{attrs:{id:"提交-commit"}},[t._v("提交 commit")]),t._v(" "),e("p",[t._v("Git 将数据看做微型文件系统的一组"),e("strong",[t._v("快照")]),t._v("。每次 commit （在 Git 中保持项目状态）它都对文件当时的状况拍照，并存储对该快照的引用，类似游戏中的保存点，它会保存项目的文件和关于文件的所有信息。commit 是 Git 中的基本单位。")]),t._v(" "),e("h3",{attrs:{id:"仓库-repository-repo"}},[t._v("仓库 Repository / repo")]),t._v(" "),e("p",[t._v("仓库是一个包含项目内容以及几个文件（在 Mac OS X 上默认地处于"),e("strong",[t._v("隐藏状态")]),t._v("）的目录，用来与 Git 进行通信。仓库可以存储在本地，或作为远程副本存储在其他计算机上。仓库是由 commit 构建的。")]),t._v(" "),e("h3",{attrs:{id:"工作目录-工作区-working-directory"}},[t._v("工作目录/工作区 Working Directory")]),t._v(" "),e("p",[t._v("工作目录是你在计算机的文件系统中看到的文件。与这些文件形成对比的是保持在仓库中（在 commit 中，在 Mac OS X 上隐藏）的文件。")]),t._v(" "),e("p",[t._v("注意：在使用 Git 时，工作目录与命令行工具的 current working directory （当前工作目录）不一样，后者是 shell 当前正在查看的目录。")]),t._v(" "),e("h3",{attrs:{id:"检出-checkout"}},[t._v("检出 Checkout")]),t._v(" "),e("p",[t._v("检出是指将仓库中的内容"),e("strong",[t._v("复制")]),t._v("到工作目录下。")]),t._v(" "),e("h3",{attrs:{id:"暂存区-暂存索引-索引-staging-area-staging-index-index"}},[t._v("暂存区/暂存索引/索引 Staging Area/Staging Index/Index")]),t._v(" "),e("p",[t._v("Git 目录下的一个文件，"),e("strong",[t._v("存储的是即将进入下个 commit 内容的信息")]),t._v("。可以将暂存区看做准备工作台，Git 将在此区域获取下个 commit。暂存索引中的文件是准备添加到仓库中的文件。")]),t._v(" "),e("h3",{attrs:{id:"sha"}},[t._v("SHA")]),t._v(" "),e("p",[e("code",[t._v("SHA")]),t._v(" 是每个 commit 的 ID 编号。以下是 commit 的 "),e("code",[t._v("SHA")]),t._v(" 示例："),e("code",[t._v("e2adf8ae3e2e4ed40add75cc44cf9d0a869afeb6")]),t._v("。")]),t._v(" "),e("p",[t._v("它是一个"),e("strong",[t._v("长 40 个字符的字符串（由 0–9 和 a–f 组成），并根据 Git 中的文件或目录结构的内容计算得出")]),t._v('。SHA 的全称是 "Secure Hash Algorithm" 安全哈希算法。')]),t._v(" "),e("h3",{attrs:{id:"分支-branch"}},[t._v("分支 Branch")]),t._v(" "),e("p",[t._v("分支是从主开发流程中分支出来的新的开发流程。这种分支开发流程可以在不更改主流程的情况下继续延伸下去。")]),t._v(" "),e("p",[t._v("回到之前关于游戏保存点的示例，你可以将分支看做在游戏中设立保存点后，尝试一个有风险的招式。如果有风险的招式不奏效，则回到保存的位置。"),e("strong",[t._v("令分支非常强大的关键之处是你可以在一个分支上设定保存点，然后切换到另一个分支并继续设定保存点。")])]),t._v(" "),e("h2",{attrs:{id:"git-三大区域"}},[t._v("Git 三大区域")]),t._v(" "),e("p",[t._v("Git 管理着三大区域，文件就在这三个区域之间移动：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("工作区域 working directory")]),t._v("：在工作区域对文件进行修改")]),t._v(" "),e("li",[e("strong",[t._v("暂存区 staging index")]),t._v("：暂存等待保存进入仓库的文件")]),t._v(" "),e("li",[e("strong",[t._v("仓库 repository")]),t._v("：通过 "),e("code",[t._v("commit")]),t._v(" 命令将修改过或新建的且已在暂存区的文件保存到仓库中，每个 commit 都有唯一的 ID，即 SHA，可以通过相应的 ID 访问特定的提交")])]),t._v(" "),e("h2",{attrs:{id:"基本终端命令"}},[t._v("基本终端命令")]),t._v(" "),e("p",[t._v("Git 操作在 Git Bash 终端中进行，常用的命令：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("ls")]),t._v(" 列出当前目录的文件（夹），当前目录")]),t._v(" "),e("li",[e("code",[t._v("mkdir")]),t._v(" 新建目录")]),t._v(" "),e("li",[e("code",[t._v("cd")]),t._v(" 更改目录")]),t._v(" "),e("li",[e("code",[t._v("rm")]),t._v(" 删除文件和目录")]),t._v(" "),e("li",[e("code",[t._v("pwd")]),t._v(" 输出工作目录（绝对路径）")])]),t._v(" "),e("h2",{attrs:{id:"新建仓库"}},[t._v("新建仓库")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-init",target:"_blank",rel:"noopener noreferrer"}},[t._v("git init 文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/setting-up-a-repository",target:"_blank",rel:"noopener noreferrer"}},[t._v("git init 教程"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("在对 Git 仓库进行 commit 或执行任何其他操作之前，需要一个实际存在的仓库。使用 "),e("code",[t._v("git init")]),t._v(" 命令新建一个仓库")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 任务")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 创建一个目录 udacity-git-course")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 在该目录中创建另一个目录 new-git-project")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 切换当前路径到 new-git-project 目录下")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 创建目录并切换到目录")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("mkdir")]),t._v(" -p udacity-git-course/new-git-project "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("cd")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$_")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 在当前目录下初始化生成一个空的 Git 仓库，创建成功后终端提示符会添加 master 关键字")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" init\n")])])]),e("ul",[e("li",[t._v("创建目录 "),e("code",[t._v("mkdir")]),t._v(" 设置的参数 "),e("code",[t._v("-p")]),t._v(" 表示如果目录已存在则不会报错，递归创建")]),t._v(" "),e("li",[t._v("在 Git Bash 里复制操作快捷键为 "),e("code",[t._v("Ctrl + Insert")]),t._v(" 粘贴快捷键为 "),e("code",[t._v("Shift + Insert")])]),t._v(" "),e("li",[t._v("命令 "),e("code",[t._v("$_")]),t._v(" 扩展到上一个命令的最后一个参数，或上一个命令（若上一个命令没有设置参数时）")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(727),alt:"新建仓库"}})]),t._v(" "),e("p",[e("code",[t._v("git init")]),t._v(" 命令的作用是在"),e("strong",[t._v("当前目录")]),t._v("下初始化生成一个空的 Git 仓库，并将所有用于跟踪内容所必要文件和目录存储于 "),e("code",[t._v(".git")]),t._v("目录下（该目录开头有个点 "),e("code",[t._v(".")]),t._v("，表示在 Mac/Linux 上它将是一个隐藏目录）。"),e("code",[t._v(".git")]),t._v(" 目录实际就是一个"),e("strong",[t._v("存储项目（当前目录下的项目）各版本的库")]),t._v("，Git 会将所有 commit 记录在这里，并跟踪所有内容！")]),t._v(" "),e("p",[e("img",{attrs:{src:v(728),alt:"git仓库"}})]),t._v(" "),e("p",[t._v("⚠️ "),e("strong",[t._v("请勿直接修改 .git 目录下的任何文件")]),t._v("。这是仓库的核心。如果你更改了文件名或文件内容，Git 可能就无法跟踪你保存在仓库中的文件，可能会丢失很多内容！可以查看这些文件，但是请勿编辑或删除这些文件。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(729),alt:"git核心"}})]),t._v(" "),e("p",[e("code",[t._v(".git")]),t._v(" 中各项内容及作用：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("config")]),t._v(" 文件：存储了所有与项目有关的配置设置，配置文件设置的配置值仅适用于当前仓库")]),t._v(" "),e("li",[e("code",[t._v("description")]),t._v(" 文件：此文件仅用于 GitWeb 程序，可忽略")]),t._v(" "),e("li",[e("code",[t._v("hooks")]),t._v(" 目录：存放客户端或服务器端脚本，以便用来连接到 Git 的不同生命周期事件")]),t._v(" "),e("li",[e("code",[t._v("info")]),t._v(" 目录：包含"),e("strong",[t._v("全局排除文件")])]),t._v(" "),e("li",[e("code",[t._v("objects")]),t._v(" 目录：存储提交的所有 commit")]),t._v(" "),e("li",[e("code",[t._v("refs")]),t._v(" 目录：此目录存储了指向 commit 的指针（通常是「分支」和「标签」）")])]),t._v(" "),e("h2",{attrs:{id:"克隆仓库"}},[t._v("克隆仓库")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-clone",target:"_blank",rel:"noopener noreferrer"}},[t._v("git 克隆文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/setting-up-a-repository",target:"_blank",rel:"noopener noreferrer"}},[t._v("git 克隆教程"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("克隆仓库是制作完全相同的仓库副本，如在制作 Web 项目可以克隆模板，简化配置步骤。使用 "),e("code",[t._v("git clone [url]")]),t._v(" 命令并传入需要克隆的 Git 仓库的路径（通常是 URL），以创建仓库副本。")]),t._v(" "),e("p",[t._v("⚠️ 请在克隆任何内容之前"),e("strong",[t._v("验证终端位置")]),t._v("，通过输入 "),e("code",[t._v("pwd")]),t._v(" 命令查询工作目录，确保命令行工具已定位于正确的目录下。由于"),e("strong",[t._v("无法创建嵌套的 Git 仓库")]),t._v("，因此需要确保终端的当前工作目录没有位于 Git 仓库中。")]),t._v(" "),e("p",[t._v("克隆项目会新建一个目录，并在这个目录下初始化一个 "),e("code",[t._v(".git")]),t._v(" 文件夹，从远程仓库拉取下所有数据放入 "),e("code",[t._v(".git")]),t._v(" 文件夹，然后从中"),e("strong",[t._v("读取最新版本的文件")]),t._v("的拷贝到新建目录下。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 切换当前目录至合理位置（无 Git 仓库），如 udcity-git-course")]),t._v("\n$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" clone https://github.com/udacity/course-git-blog-project\n")])])]),e("p",[e("img",{attrs:{src:v(730),alt:"克隆仓库"}})]),t._v(" "),e("p",[e("img",{attrs:{src:v(731),alt:"course_git_blog_poject"}})]),t._v(" "),e("p",[t._v("💡 在克隆仓库时，会在当前目录下创建一个同名目录，若需要自定义本地仓库的名字，可在运行上述命令结束后手动重命名；或在终端上使用 "),e("code",[t._v("mv")]),t._v(" 重命名；或在克隆时指定本地创建的仓库名字 "),e("code",[t._v("git clone [url] project_name")])]),t._v(" "),e("p",[t._v("💡 使用 "),e("code",[t._v("git clone")]),t._v(" 命令会在当前工作目录下创建新的仓库，但 shell 工作目录并不改变（根据终端的提示符进行判断 shell 当前所在的目录），如果位于 Git 仓库目录下，提示符将包含一个用小括号包含的关键字 "),e("code",[t._v("master")]),t._v("（或其他分支的名称）。"),e("strong",[t._v("克隆结束后需要使用 "),e("code",[t._v("cd")]),t._v(" 命令")]),t._v("切换到新的仓库中，才可以对仓库进行后续操作。")]),t._v(" "),e("h2",{attrs:{id:"仓库状态"}},[t._v("仓库状态")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-status",target:"_blank",rel:"noopener noreferrer"}},[t._v("git status 文档"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-status",target:"_blank",rel:"noopener noreferrer"}},[t._v("git status 教程"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git status")]),t._v(" 查询仓库状态，返回关于仓库的信息：")]),t._v(" "),e("ul",[e("li",[t._v("目前所在的分支")]),t._v(" "),e("li",[t._v("已在工作目录中被创建但 Git 尚未开始跟踪的新文件")]),t._v(" "),e("li",[t._v("Git 正在跟踪的已修改文件")]),t._v(" "),e("li",[t._v("……")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(732),alt:"克隆仓库状态"}})]),t._v(" "),e("ul",[e("li",[e("code",[t._v("On branch master")]),t._v(" 表示 Git 位于 "),e("code",[t._v("master")]),t._v(" 分支（默认分支）上")]),t._v(" "),e("li",[e("code",[t._v("Your branch is up-to-date with 'origin/master'.")]),t._v(" 由于该仓库是从远程仓库克隆而创建的，这部分告诉我们项目是否与所复制的仓库"),e("strong",[t._v("保持同步状态")]),t._v("（目前显示是最新状态）")]),t._v(" "),e("li",[e("code",[t._v("nothing to commit, working directory clean")]),t._v(" 表示没有任何待定（提交到仓库）的更改")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(733),alt:"新建仓库状态"}})]),t._v(" "),e("p",[t._v("新建仓库状态与克隆所建（有内容的）仓库类似，但是由于其并未包含任何 commit 所以会返回 "),e("code",[t._v("No commits yet")]),t._v(" 的信息")]),t._v(" "),e("ul",[e("li",[t._v("应该在任何一个其他 git 命令之前和之后运行 "),e("code",[t._v("git status")]),t._v(" 命令，确保修改得到了正确的处理（提交）")]),t._v(" "),e("li",[t._v("在一段时间之后再回到某个项目时，始终先运行 "),e("code",[t._v("git status")]),t._v(" 命令以检出该项目，并初步了解仓库的操作信息")])]),t._v(" "),e("h2",{attrs:{id:"查看仓库历史"}},[t._v("查看仓库历史")]),t._v(" "),e("p",[t._v("在版本控制中应该"),e("strong",[t._v("频繁")]),t._v("提交"),e("strong",[t._v("详细")]),t._v("的记录，以便追踪项目逐步进展情况。Git 会自动记录创建提交时的日期时间和所作的内容更改，用户只需要设置每次 commit 标题或说明。")]),t._v(" "),e("p",[t._v("使用命令 "),e("code",[t._v("git log")]),t._v(" 或 "),e("code",[t._v("git show")]),t._v(" 查看查看仓库历史记录：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("git log")]),t._v(" 显示仓库中所有 commit 的信息")]),t._v(" "),e("li",[e("code",[t._v("git show")]),t._v(" 显示有关给定 commit 的信息，因此需要提供所需查询的 commit ID（即 SHA）")])]),t._v(" "),e("h3",{attrs:{id:"命令-git-log"}},[t._v("命令 "),e("code",[t._v("git log")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(734),alt:"git log"}})]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git log")]),t._v(" 默认情况下返回 commit 的以下信息：")]),t._v(" "),e("ul",[e("li",[t._v("SHA：每个 commit 的完整 SHA。每个 SHA 都是唯一的（即每个 commit 都产生独一无二标记），一般不需要查看整个 SHA，只需知道前 6-8 个字符即可")]),t._v(" "),e("li",[t._v("作者：即提交信息，可在 "),e("code",[t._v("user.name")]),t._v(" 中设置")]),t._v(" "),e("li",[t._v("日期")]),t._v(" "),e("li",[t._v("消息：提交者填写的注释信息，以描述该次 commit 的作用。")])]),t._v(" "),e("h4",{attrs:{id:"选项-oneline"}},[t._v("选项 "),e("code",[t._v("--oneline")])]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git log")]),t._v(" 可以设置选项 "),e("code",[t._v("--oneline")]),t._v(" 以显示简化版的历史信息，"),e("strong",[t._v("每个 commit 显示一行")]),t._v("，包括该提交的 SHA 的前七个字符，以及提交说明")]),t._v(" "),e("h4",{attrs:{id:"选项-stat"}},[t._v("选项 "),e("code",[t._v("--stat")])]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git log")]),t._v(" 可以设置选项 "),e("code",[t._v("--stat")]),t._v("（代表 statistics 统计）以显示 commit 中"),e("strong",[t._v("被更改的文件以及添加或删除的行数")]),t._v("。以 "),e("code",[t._v("+")]),t._v(" 或 "),e("code",[t._v("-")]),t._v(" 号表示添加或删除的行数，最后显示一个摘要包含修改/删除的总文件数和总行数。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(735),alt:"列出了被更改的文件以及添加或删除的行数"}})]),t._v(" "),e("h4",{attrs:{id:"选项-p"}},[t._v("选项 "),e("code",[t._v("-p")])]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git log")]),t._v(" 可以设置"),e("a",{attrs:{href:"https://git-scm.com/docs/git-diff#_generating_patches_with_p",target:"_blank",rel:"noopener noreferrer"}},[t._v("选项"),e("OutboundLink")],1),t._v(" "),e("code",[t._v("-p")]),t._v("（或 "),e("code",[t._v("--p")]),t._v("），代表 patch 修补，以显示具体的修改内容，以对比形式 "),e("code",[t._v("diff")]),t._v(" 列出。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(736),alt:"查看修改内容"}})]),t._v(" "),e("ul",[e("li",[t._v("🔵 "),e("code",[t._v("diff")]),t._v(" 标注行表示正在对比的文件（可能是文件名文件，但也支持追踪重命名后的两个同源文件），其中第一版（原版）文件以目录 "),e("code",[t._v("a")]),t._v(" 表示，第二版文件以目录 "),e("code",[t._v("b")]),t._v(" 表示（这两个 "),e("code",[t._v("a")]),t._v("、"),e("code",[t._v("b")]),t._v(" 目录并不会在库里实际可见），下方 "),e("code",[t._v("--- a/index.html")]),t._v(" 和 "),e("code",[t._v("+++ b/index.html")]),t._v(" 表意一样")]),t._v(" "),e("li",[t._v("🔶 "),e("code",[t._v("index")]),t._v(" 标注行表示文件第一版的哈希值 "),e("code",[t._v("0382322")]),t._v(" 和第二版的哈希值 "),e("code",[t._v("43f5b28")]),t._v("（与 SHA 不同）通常不重要可忽略")]),t._v(" "),e("li",[t._v("❤️ "),e("code",[t._v("---")]),t._v(" 表示旧版本，"),e("code",[t._v("+++")]),t._v(" 表示当前版本")]),t._v(" "),e("li",[t._v("🔍 "),e("code",[t._v("@@")]),t._v(" 标注行展示代码定位和数量，"),e("code",[t._v("-")]),t._v(" 表示原版本，"),e("code",[t._v("+")]),t._v(" 表示当前版本。他们后面两个数字分别表示：第一个数字是起始代码的位置（行号），第二个数字表示显示代码的数量（行数）\n"),e("ul",[e("li",[e("code",[t._v("-15,83")]),t._v(" 表示旧版本代码从第 15 行开始，显示了 83 行（即原始版本截取了 83 行代码显示）")]),t._v(" "),e("li",[e("code",[t._v("+15,85")]),t._v(" 表示当前版本从第 15 行开始，由于增添了代码，所以第二版本显示了 85 行")])])]),t._v(" "),e("li",[t._v("✏️ 代码行中显示了在 commit 中实际进行的更改\n"),e("ul",[e("li",[t._v("代码行开头标注减号 "),e("code",[t._v("-")]),t._v(" 表示该行在文件原始版本中，但是被 commit 删除的行")]),t._v(" "),e("li",[t._v("代码行开头标注加号 "),e("code",[t._v("+")]),t._v(" 表示该行是 commit 新加的行")])])])]),t._v(" "),e("p",[t._v("💡 "),e("strong",[t._v("Git 以行为单位追踪修改，对于行的操作可以是删除会插入")]),t._v("。但实际操作可能只是增添了一个空格或缩进（而非把整一行删除后在插入），而补丁输出显示所有行先被删掉，然后在新的缩进位置又被重新添加。可以对命令 "),e("code",[t._v("git log -p")]),t._v(" 设置选项 "),e("code",[t._v("-w")]),t._v(" "),e("strong",[t._v("忽略空格更改")]),t._v("，在查询具体代码修改时不显示这一类的更改")]),t._v(" "),e("h3",{attrs:{id:"命令-git-show"}},[t._v("命令 "),e("code",[t._v("git show")])]),t._v(" "),e("p",[t._v("使用命令 "),e("code",[t._v("git log")]),t._v(" 查询所有的 commit（也通过设置参数提供 SHA，作为最后一个参数，只需提供七个字符，只显示在所提供的 SHA "),e("strong",[t._v("之前提交的所有 commit 信息")]),t._v("）。若只需查看特定一个 commit 可以使用命令 "),e("code",[t._v("git show")]),t._v("，默认显示最近依次 commit，可以将 SHA 作为最后一个参数，访问特定的 commit。")]),t._v(" "),e("p",[t._v("默认显示信息和命令 "),e("code",[t._v("git log -p")]),t._v(" 类似：")]),t._v(" "),e("ul",[e("li",[t._v("commit")]),t._v(" "),e("li",[t._v("作者")]),t._v(" "),e("li",[t._v("日期")]),t._v(" "),e("li",[t._v("commit 消息")]),t._v(" "),e("li",[t._v("补丁信息")])]),t._v(" "),e("p",[t._v("此外该命令也可以设置类似的选项：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("--stat")]),t._v(" 显示更改了多少文件，以及添加/删除的行数")]),t._v(" "),e("li",[e("code",[t._v("-p")]),t._v(" 或 "),e("code",[t._v("--patch")]),t._v(" - 显示默认补丁信息")]),t._v(" "),e("li",[e("code",[t._v("-w")]),t._v(" 忽略空格变化")])]),t._v(" "),e("h2",{attrs:{id:"添加-commit"}},[t._v("添加 commit")]),t._v(" "),e("p",[t._v("为了让 git 跟踪项目的新建的文件，要将这些文件提交到仓库。")]),t._v(" "),e("p",[t._v("但是提交文件需要先放入暂存区，因此流程为：")]),t._v(" "),e("ol",[e("li",[t._v("在"),e("strong",[t._v("工作区")]),t._v("的修改需要使用命令 "),e("code",[t._v("git.add")]),t._v(" 将它们添加到"),e("strong",[t._v("暂存区")]),t._v(" stage")]),t._v(" "),e("li",[t._v("使用命令 "),e("code",[t._v("git.commit")]),t._v(" 将暂存区文件提交到"),e("strong",[t._v("仓库")])])]),t._v(" "),e("h3",{attrs:{id:"添加到暂存区"}},[t._v("添加到暂存区")]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git add")]),t._v(" 将新建或修改文件添加到暂存区，在添加暂存区之前应该使用命令 "),e("code",[t._v("git status")]),t._v(" 查看工作区作出了几个更改（文件）")]),t._v(" "),e("p",[e("img",{attrs:{src:v(737),alt:"将工作区文件添加到暂存区"}})]),t._v(" "),e("p",[t._v("在目录 "),e("code",[t._v("new-git-project")]),t._v(" 仓库中新建了三个文件 "),e("code",[t._v("index.html")]),t._v("、"),e("code",[t._v("css/app.css")]),t._v("、"),e("code",[t._v("js/app.js")]),t._v("，将其添加到暂存区 stage 中")]),t._v(" "),e("p",[e("img",{attrs:{src:v(738),alt:"新建文件后查看 git status"}})]),t._v(" "),e("p",[t._v("新建三个文件后使用命令 "),e("code",[t._v("git status")]),t._v(" 输出提示为 "),e("code",[t._v("Untracked files")]),t._v(" 包含这三个文件，即 git 还没有跟踪这些文件。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(739),alt:"暂存 html 文件"}})]),t._v(" "),e("p",[t._v("使用命令 "),e("code",[t._v("git add <file>")]),t._v(" 将 "),e("code",[t._v("<file>")]),t._v(" 文件添加到暂存区。使用命令 "),e("code",[t._v("git status")]),t._v(" 查询输出显示 "),e("code",[t._v("index.html")]),t._v(" 现在位于 "),e("code",[t._v('"Changes to be committed"')]),t._v(" 分类下（该区域显示了位于暂存区的文件，这些文件等待 commit）")]),t._v(" "),e("p",[t._v("⚠️ "),e("code",[t._v('"Changes to be committed"')]),t._v(" 下方的帮助文本提示当不小心运行了 "),e("code",[t._v("git add")]),t._v(" 将文件错误地添加到了暂存区，可使用该命令将文件从暂存区删掉（但该操作与 shell 的 "),e("code",[t._v("rm")]),t._v(" 命令不同），"),e("code",[t._v("unstage")]),t._v(" 是指撤销暂存把文件移回工作区，"),e("strong",[t._v("并不破坏文件")]),t._v("；相应的将文件从工作目录移到暂存区叫做 "),e("code",[t._v("staging")]),t._v("暂存；如果已移动文件，则叫做 "),e("code",[t._v("staged")]),t._v(" 已暂存。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 将 <file> 文件从暂存区删除，")]),t._v("\n$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" --cached "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("file"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),e("p",[e("img",{attrs:{src:v(740),alt:"暂存剩余的所有文件"}})]),t._v(" "),e("ul",[e("li",[t._v("命令 "),e("code",[t._v("git add <file1> <file2> … <fileN>")]),t._v(" 可接受多个文件名，用空格 Space 分隔")]),t._v(" "),e("li",[t._v("命令 "),e("code",[t._v("git add .")]),t._v(" 使用句点 "),e("code",[t._v(".")]),t._v(" 来代替文件列表，添加当前目录（包含的所有文件以及所有嵌套文件）至暂存区")])]),t._v(" "),e("h3",{attrs:{id:"添加到仓库"}},[t._v("添加到仓库")]),t._v(" "),e("p",[t._v("使用命令 "),e("code",[t._v("git commit")]),t._v(" 将暂存区的（修改后）文件添加到仓库。运行命令后 git 会调用并打开"),e("strong",[t._v("代码编辑器")]),t._v("，此时终端会冻结，以等待用户完成在代码编辑器中输入 Commit 消息解释说明；待用户关闭编辑器窗口，终端再输出该次 commit 信息并完成提交")]),t._v(" "),e("p",[t._v("在 Shell 终端输入命令 "),e("code",[t._v("git commit")]),t._v(" 后 git 打开预设的代码编辑器 Visual Studio Code（默认打开内置的代码编辑器 Vim，可在 Git 配置中设置")]),t._v(" "),e("p",[t._v("参考："),e("a",{attrs:{href:"https://help.github.com/articles/associating-text-editors-with-git/",target:"_blank",rel:"noopener noreferrer"}},[t._v("将文本编辑器与 git 相关联"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("img",{attrs:{src:v(741),alt:"在代码编辑器 VS Code 中输入 commit 消息"}})]),t._v(" "),e("ul",[e("li",[t._v("代码编辑器打开的文件提供能注释，指导填写 commit 信息：\n"),e("ul",[e("li",[t._v("第一段精确地告诉了我们需要执行的操作，为该 commit 提供一条消息")]),t._v(" "),e("li",[t._v("任何以字符 "),e("code",[t._v("#")]),t._v(" 开头的行将被忽略")]),t._v(" "),e("li",[t._v("这将是初始提交 "),e("code",[t._v("Initial commit")])]),t._v(" "),e("li",[t._v("最后列出了提交 commit 的文件列表")])])]),t._v(" "),e("li",[t._v("在代码编辑器第一行输入这次的 commit 信息为 "),e("code",[t._v("Initial commit")]),t._v(" 以表示这是首次提交")]),t._v(" "),e("li",[t._v("关闭 git commit 命令打开的代码编辑器窗口（关闭面板/标签页是不够的）")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(742),alt:"提交后终端输出 commit 信息"}})]),t._v(" "),e("p",[t._v("关闭代码编辑器后终端显示了这次 commit 的信息，包括这次提交对应的 SHA、修改的文件数、更改的代码行数以及被添加的具体文件。")]),t._v(" "),e("p",[t._v("💡 如果你要编写的提交说明很简短，可以直接在命令 "),e("code",[t._v("git commit")]),t._v(" 设置选项 "),e("code",[t._v("-m")]),t._v(" 传入信息（而不必打开代码编辑器）如示例可以使用命令 "),e("code",[t._v('$ git commit -m "Initial commit"')])]),t._v(" "),e("p",[t._v("💡 提交 commit 原则是每个 commit 应该记录一项更改。一个 commit 不应包含不相关的更改，对于多项更改先进行一项更改，提交该更改，然后再进行第二项更改。如果一个更改有 bug，你需要撤消该更改时，则不用同时撤消另一个更改。")]),t._v(" "),e("p",[t._v("💡 编写 Git Commit Message 建议")]),t._v(" "),e("ul",[e("li",[t._v("消息篇幅简短（少于 60 个字符）")]),t._v(" "),e("li",[t._v("解释提交的作用（不是如何更改（这是命令 "),e("code",[t._v("git log -p")]),t._v(" 的目的，通过展示具体的代码可知）或为何更改！）")]),t._v(" "),e("li",[t._v("可以添加解释提交的原因。在代码编辑器中编写提交说明时，第一行是消息本身，"),e("strong",[t._v("消息之后空一行")]),t._v("，然后输入正文或说明，包括关于为何需要该 commit 的原因详情（例如 URL 链接）。（而查看时如果使用了命令 "),e("code",[t._v("git log --oneline")]),t._v(" 只能查看说明（第一行），应使用 "),e("code",[t._v("git log")]),t._v(" 或 "),e("code",[t._v("git show")]),t._v(" 以查看完整的说明正文）")]),t._v(" "),e("li",[t._v("请勿使用单词 "),e("code",[t._v("and")]),t._v("（如果你必须使用则说明这一次提交可能进行了太多的更改，将这些更改拆分为独立的 commit）")]),t._v(" "),e("li",[t._v("在编写提交说明时保持一致性，可以使用短语句式 "),e("code",[t._v("This commit will…")])])]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://chris.beams.io/posts/git-commit/",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何编写 Git Commit Message"),e("OutboundLink")],1),t._v("（"),e("a",{attrs:{href:"https://www.jianshu.com/p/0117334c75fc",target:"_blank",rel:"noopener noreferrer"}},[t._v("译文"),e("OutboundLink")],1),t._v(" ）")]),t._v(" "),e("li",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Commit message 和 Change log 编写指南"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"相关-commit-引用"}},[t._v("相关 commit 引用")]),t._v(" "),e("p",[t._v("可以使用 SHA、标签、分支和 "),e("code",[t._v("HEAD")]),t._v(" 指针引用 commit。有时候这些并不足够，可能需要引用相对于另一个 commit 的 commit。可以使用特殊的「祖先引用」字符来告诉 git 这些相对引用：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("^")]),t._v("表示父 commit")]),t._v(" "),e("li",[e("code",[t._v("~")]),t._v("表示第一个父 commit，该字符 "),e("code",[t._v("~")]),t._v("（与 "),e("code",[t._v("^")]),t._v(" 字符相比）作用主要体现在通过合并而创建的 commit 中。合并 commit 具有两个父级，"),e("code",[t._v("^")]),t._v(" 引用表示第一个父 commit，即当你运行 "),e("code",[t._v("git merge")]),t._v(" 时所处的分支；而 "),e("code",[t._v("^2")]),t._v(" 表示第二个父 commit，即被合并的分支。")])]),t._v(" "),e("p",[t._v("常用的 commit 相对引用：")]),t._v(" "),e("ul",[e("li",[t._v("父 commit\n"),e("ul",[e("li",[e("code",[t._v("HEAD^")])]),t._v(" "),e("li",[e("code",[t._v("HEAD~")])]),t._v(" "),e("li",[e("code",[t._v("HEAD~1")])])])]),t._v(" "),e("li",[t._v("祖父 commit\n"),e("ul",[e("li",[e("code",[t._v("HEAD^^")])]),t._v(" "),e("li",[e("code",[t._v("HEAD~2")])])])]),t._v(" "),e("li",[t._v("曾祖父 commit\n"),e("ul",[e("li",[e("code",[t._v("HEAD^^^")])]),t._v(" "),e("li",[e("code",[t._v("HEAD~3")])])])])]),t._v(" "),e("h2",{attrs:{id:"撤销-commit"}},[t._v("撤销 commit")]),t._v(" "),e("p",[t._v("撤销 commit 可以将相应的提交从仓库中删除，但使用时需慎重。")]),t._v(" "),e("h3",{attrs:{id:"修改最近一次-commit"}},[t._v("修改最近一次 commit")]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git commit --amend")]),t._v(" 更改最近的 commit。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("修改 commit 信息：如果工作目录没有内容（也就是仓库中没有任何未 commit 的更改），运行命令 "),e("code",[t._v("git commit --amend")]),t._v(" 代码编辑器将打开，并显示原始 commit 消息。此时可以纠正拼错的单词或提供重新表述，然后保存文件并关闭编辑器，以更新最近一次 commit 消息。")])]),t._v(" "),e("li",[e("p",[t._v("增添修改：若提交中有纰漏，可以再次编辑文件，暂存文件，但在提交时使用命令 "),e("code",[t._v("git commit --amend")]),t._v(" 以更新最近的 commit，而不是创建新的 commit（以避免针对完全相同的任务由于更新纰漏造成两次提交）")])])]),t._v(" "),e("h3",{attrs:{id:"还原-commit"}},[t._v("还原 commit")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-revert",target:"_blank",rel:"noopener noreferrer"}},[t._v("git-revert"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/undoing-changes",target:"_blank",rel:"noopener noreferrer"}},[t._v("git revert"),e("OutboundLink")],1),t._v(" 教程")])]),t._v(" "),e("p",[t._v("还原 revert 是指 git 执行和 commit 中的更改"),e("strong",[t._v("完全相反的更改")]),t._v("。命令 "),e("code",[t._v("git revert <SHA-of-commit-to-revert>")]),t._v(" 撤销目标 commit 同时创建一个新的 commit 记录这次还原更改（提交信息推荐使用默认提供的 commit 消息）")]),t._v(" "),e("h3",{attrs:{id:"重置-commit"}},[t._v("重置 commit")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-reset",target:"_blank",rel:"noopener noreferrer"}},[t._v("git-reset"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git 工具 - 重置揭密"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection#Ancestry-References",target:"_blank",rel:"noopener noreferrer"}},[t._v("祖先引用"),e("OutboundLink")],1),t._v("（"),e("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%80%89%E6%8B%A9%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC",target:"_blank",rel:"noopener noreferrer"}},[t._v("中译版"),e("OutboundLink")],1),t._v("）")])]),t._v(" "),e("p",[t._v("⚠️ 重置 reset 会清除 commit！它所包含的内容也会消失，请谨慎使用。命令 "),e("code",[t._v("git rest <reference-to-commit>")]),t._v(" 移动 "),e("code",[t._v("HEAD")]),t._v(" 指针「回滚」到相对引用所对应的 commit，并清除当前分支该 commit 前方的所有提交，根据命令设置的选项对这些 commit 的更改「撤回」到相应的空间")]),t._v(" "),e("p",[e("img",{attrs:{src:v(743),alt:"重置 commit"}})]),t._v(" "),e("ul",[e("li",[t._v("命令设置选项 "),e("code",[t._v("--mixed")]),t._v("（默认值）把移动后 "),e("code",[t._v("HEAD")]),t._v(" 指针前的 commit 中做出的更改移至工作目录中")]),t._v(" "),e("li",[t._v("命令设置选项 "),e("code",[t._v("--soft")]),t._v(" 把移动后 "),e("code",[t._v("HEAD")]),t._v(" 指针前的 commit 中做出的更改移至暂存区")]),t._v(" "),e("li",[t._v("命令设置选项 "),e("code",[t._v("--hard")]),t._v(" 更改被清除。")])]),t._v(" "),e("p",[t._v("重置到父 commit 命令设置选项 "),e("code",[t._v("--mixed")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(744),alt:"重置 commit 且更改移至工作区"}})]),t._v(" "),e("ul",[e("li",[t._v("可以重置到 SHA 所对应的特定 commit 使用命令 "),e("code",[t._v("git reset <SHA>")])]),t._v(" "),e("li",[t._v("在执行 reset 操作前请 💡备份分支💡，通常会在最近的 commit 上创建一个 "),e("code",[t._v("backup")]),t._v(" 分支，以便出现错误可以返回这些 commit")])]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" branch backup\n")])])]),e("ul",[e("li",[e("p",[t._v("恢复原有 commit 只需要（先从工作目录中删除未 commit 的更改）将当前分支指向 "),e("code",[t._v("backup")]),t._v(" 分支即可，会进行快进合并将 "),e("code",[t._v("backup")]),t._v(" 合并到当前分支，把当前分支向上移动到和 "),e("code",[t._v("backup")]),t._v(" 一样的点")]),t._v(" "),e("p",[t._v("示例中使用 "),e("code",[t._v("git reset HEAD^")]),t._v(" 将分支重置到 父 commit，撤回的更改即文件 "),e("code",[t._v("index.html")]),t._v(" 移到工作区。要恢复分支所有 commit 需要先删除工作区的 "),e("code",[t._v("index.html")]),t._v(" 文件")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout -- index.html\n$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" merge backup\n")])])])]),t._v(" "),e("li",[e("p",[t._v("git 会在完全清除任何内容之前，持续跟踪大约 30 天。使用命令 "),e("code",[t._v("git reflog")]),t._v("可调用这些内容 。请参阅以下链接以了解详情")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-reflog",target:"_blank",rel:"noopener noreferrer"}},[t._v("git-reflog"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/rewriting-history",target:"_blank",rel:"noopener noreferrer"}},[t._v("重写历史记录"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("reflog，你的安全屏障"),e("OutboundLink")],1)])])])]),t._v(" "),e("h2",{attrs:{id:"压制-commit"}},[t._v("压制 commit")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/book/en/v2/Git-Branching-Rebasing",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git 分支 - 变基"),e("OutboundLink")],1),t._v("（"),e("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA",target:"_blank",rel:"noopener noreferrer"}},[t._v("中译版"),e("OutboundLink")],1),t._v("）")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-rebase",target:"_blank",rel:"noopener noreferrer"}},[t._v("git-rebase"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/rewriting-history#git-rebase",target:"_blank",rel:"noopener noreferrer"}},[t._v("Atlassian 博客"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git rebase")]),t._v(" 将多个 commit 压制 squash，即将多个 commit 合并成一个 commit。"),e("code",[t._v("git rebase")]),t._v(" 也称为 "),e("strong",[t._v("变基")]),t._v("，将 commit 移动到一个新基底 base 上，如命令 "),e("code",[t._v("git rebase -i HEAD~3")]),t._v(" （选项 "),e("code",[t._v("-i")]),t._v(" 代表 交互式 逐步操作，推荐使用）告诉 Git 使用 "),e("code",[t._v("HEAD~3")]),t._v(" 作为其他所有 commit （"),e("code",[t._v("HEAD~2")]),t._v("、"),e("code",[t._v("HEAD~1")]),t._v(" 和 "),e("code",[t._v("HEAD")]),t._v("）将连接到的基底。")]),t._v(" "),e("p",[t._v("使用命令 "),e("code",[t._v("git rebase -i HEAD~3")]),t._v(" 将最近三个 commit 压制为一个")]),t._v(" "),e("p",[t._v("🎦 "),e("a",{attrs:{href:"https://www.jianguoyun.com/p/DeXt5i8QjNDGBxjL-uAD",target:"_blank",rel:"noopener noreferrer"}},[t._v("压制 commit"),e("OutboundLink")],1)]),t._v(" "),e("ul",[e("li",[e("p",[t._v("在此操作中我必要进行"),e("strong",[t._v("强制推送")]),t._v("分支。我不得不这样做，因为 GitHub 试图阻止我意外删除 commit。因为我使用了 "),e("code",[t._v("git rebase")]),t._v(" 命令，实际上清除三个分别记录我添加了佛罗里达、巴黎和苏格兰的 commit。我使用 git rebase 将这些 commit 合并或压制为单个 commit，相当于创建一个具有新 SHA 的提交。当我尝试使用 "),e("code",[t._v("git push")]),t._v(" 将此 commit 推送至 GitHub 时，GitHub 知道接受此推送会删除那三个单独 commit，所以它拒绝了（这实际上是对你的一种帮助，确保你已经审查过正在推送的 commit 和 GitHub 上的 commit，以验证你不会意外覆盖你在远程仓库上存储的内容！）。因此，我不得不使用 "),e("code",[t._v("git push -f")]),t._v(" 强制推送这些 commit。")])]),t._v(" "),e("li",[e("p",[t._v("命令 "),e("code",[t._v("git rebase")]),t._v(" 根据选项不同可执行不同的命令")]),t._v(" "),e("ul",[e("li",[t._v("设置选项 "),e("code",[t._v("p")]),t._v(" 或 "),e("code",[t._v("pick")]),t._v(" 表示 commit "),e("strong",[t._v("保持原样")])]),t._v(" "),e("li",[t._v("设置选项 "),e("code",[t._v("r")]),t._v("或 "),e("code",[t._v("reword")]),t._v(" 表示保留 commit 的内容，但修改 commit 说明")]),t._v(" "),e("li",[t._v("设置选项 "),e("code",[t._v("e")]),t._v(" 或 "),e("code",[t._v("edit")]),t._v(" 表示保留 commit 的内容，但先不要执行 commit，以便：\n"),e("ul",[e("li",[t._v("添加新内容或文件")]),t._v(" "),e("li",[t._v("删除内容或文件")]),t._v(" "),e("li",[t._v("修改即将 commit 的内容")])])]),t._v(" "),e("li",[t._v("设置选项 "),e("code",[t._v("s")]),t._v(" 或 "),e("code",[t._v("squash")]),t._v(" 表示将此 commit 的更改"),e("strong",[t._v("结合")]),t._v("到之前的 commit 中（列表中位于其上面的 commit ）")]),t._v(" "),e("li",[t._v("设置选项 "),e("code",[t._v("f")]),t._v(" 或 "),e("code",[t._v("fixup")]),t._v(" 表示将此 commit 的更改结合到前一个 commit 中，但删除提交说明")]),t._v(" "),e("li",[t._v("设置选项 "),e("code",[t._v("x")]),t._v(" 或 "),e("code",[t._v("exec")]),t._v(" 表示运行 shell 命令")]),t._v(" "),e("li",[t._v("设置选项 "),e("code",[t._v("d")]),t._v(" 或 "),e("code",[t._v("drop")]),t._v(" 表示删除 commit")])])])]),t._v(" "),e("p",[t._v("⚠️ "),e("code",[t._v("git rebase")]),t._v(" 命令非常强大，可以帮助你编辑提交说明、重新排序 commit、合并 commit 等，但可能由于变基破环远程协作的流程。如果你在与其他开发者协作，那么他们可能已经在使用你推送的 commit。如果你随后使用 "),e("code",[t._v("git rebase")]),t._v(" 来进行更改，并强行推送 commit，则其他开发者现在将无法与远程仓库同步。他们需要对自己的 Git 仓库进行一些复杂的手术，使它们的仓库回到工作状态……甚至可能连这一点都做不了；他们可能得抛弃之前的所有工作，使用你新变基过且强制推送的 commit 重新开始。"),e("strong",[t._v("因此如果你已推送了你想进行变基的 commit，则不应变基。")])]),t._v(" "),e("h2",{attrs:{id:"查看更改"}},[t._v("查看更改")]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git diff")]),t._v(" 查看当前工作区"),e("strong",[t._v("已加入 git 跟踪的文件，但是尚未提交的更改")]),t._v("。实际上 "),e("code",[t._v("git log -p")]),t._v(" 其实就是在后台使用了 "),e("code",[t._v("git diff")]),t._v("。命令 "),e("code",[t._v("git diff")]),t._v(" 输出工作区修改的具体信息：")]),t._v(" "),e("ul",[e("li",[t._v("已经修改的文件")]),t._v(" "),e("li",[t._v("添加/删除的行所在的位置")]),t._v(" "),e("li",[t._v("执行的实际更改")])]),t._v(" "),e("p",[t._v("在 "),e("code",[t._v("index.html")]),t._v(" 中重新组织标题的措辞，将标题从"),e("code",[t._v("Expedition")]),t._v(" 改为 "),e("code",[t._v("Adventure")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(745),alt:"查看文件具体更改"}})]),t._v(" "),e("h2",{attrs:{id:"忽略文件"}},[t._v("忽略文件")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository#Ignoring-Files",target:"_blank",rel:"noopener noreferrer"}},[t._v("忽略文件"),e("OutboundLink")],1),t._v("|"),e("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93",target:"_blank",rel:"noopener noreferrer"}},[t._v("中"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/gitignore#_pattern_format",target:"_blank",rel:"noopener noreferrer"}},[t._v("gitignore 匹配模式"),e("OutboundLink")],1),t._v(" git 文档")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://help.github.com/articles/ignoring-files/",target:"_blank",rel:"noopener noreferrer"}},[t._v("忽略文件"),e("OutboundLink")],1),t._v(" GitHub 文档")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.gitignore.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("gitignore.io"),e("OutboundLink")],1),t._v("：提供了针对不同编程语言预设的 "),e("code",[t._v(".gitignore")]),t._v(" 文件下载")])]),t._v(" "),e("p",[t._v("文件 "),e("code",[t._v(".gitignore")]),t._v(" 用来告诉 git 不应跟踪的文件。如果想将某些文件保留在项目的目录结构中，但却不想提交到项目中进行跟踪，可以将这些文件记录在 "),e("code",[t._v(".gitignore")]),t._v("文件中")]),t._v(" "),e("p",[t._v("在项目目录下新建了 "),e("code",[t._v("project.docx")]),t._v(" 文件，但不需要进行跟踪.将该文件添加到 "),e("code",[t._v(".gitignore")]),t._v(" 文件中，并通过命令 "),e("code",[t._v("git status")]),t._v(" 查看监测状态")]),t._v(" "),e("p",[e("img",{attrs:{src:v(746),alt:"忽略文件"}})]),t._v(" "),e("ul",[e("li",[e("code",[t._v(".gitignore")]),t._v(" 文件应该放在 "),e("code",[t._v(".git")]),t._v(" 目录所在的目录（一般是项目的根目录）")]),t._v(" "),e("li",[t._v("由于在 Windows 系统中无法创建没有文件名的文件，推荐使用代码编辑器如 VS Code 创建 "),e("code",[t._v(".gitignore")])]),t._v(" "),e("li",[t._v("使用"),e("strong",[t._v("通配符")]),t._v("批量忽略文件名符合规则的文件。常见通配符如下\n"),e("ul",[e("li",[e("code",[t._v("*")]),t._v(" 字符匹配 0 个或多个字符")]),t._v(" "),e("li",[e("code",[t._v("?")]),t._v(" 字符匹配 1 个字符")]),t._v(" "),e("li",[e("code",[t._v("[abc]")]),t._v(" 与 "),e("code",[t._v("a")]),t._v("、"),e("code",[t._v("b")]),t._v(" 或 "),e("code",[t._v("c")]),t._v(" 匹配")])])])]),t._v(" "),e("h2",{attrs:{id:"标签"}},[t._v("标签")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[t._v("git 基础知识 - "),e("a",{attrs:{href:"https://git-scm.com/book/en/v2/Git-Basics-Tagging",target:"_blank",rel:"noopener noreferrer"}},[t._v("添加标签"),e("OutboundLink")],1),t._v("|"),e("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE",target:"_blank",rel:"noopener noreferrer"}},[t._v("中"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-tag",target:"_blank",rel:"noopener noreferrer"}},[t._v("git tag"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git tag")]),t._v(" 可对特定的 commit 进行标记，以更适合阅读和记忆的方式将该 commit 与其他提交区分出来。标签是关联相应 commit 的永久指针（与之相对的是分支指针 "),e("code",[t._v("<HEAD>")]),t._v(" 随 commit 移动）。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(747),alt:"添加标签"}})]),t._v(" "),e("ul",[e("li",[t._v("命令 "),e("code",[t._v("git tag <tag_name>")]),t._v(" 为最近的 commit 添加轻量级标签，可以设置选项 "),e("code",[t._v("-a")]),t._v(" 创建带注释的标签，提供更详细的信息，一般在标签注释中可以记录如下信息\n"),e("ul",[e("li",[t._v("标签创建者")]),t._v(" "),e("li",[t._v("标签创建日期")]),t._v(" "),e("li",[t._v("标签消息")])])]),t._v(" "),e("li",[t._v("需要对特定（以前）commit 添加标签，可以在命令 "),e("code",[t._v("git tag")]),t._v(" 最后设置 commit 相对应的 SHA，如 "),e("code",[t._v("$ git tag -a v1.0 a87984")])])]),t._v(" "),e("h3",{attrs:{id:"查询标签"}},[t._v("查询标签")]),t._v(" "),e("p",[t._v("查询标签有多种方法：")]),t._v(" "),e("ul",[e("li",[t._v("命令 "),e("code",[t._v("git tag")]),t._v(" 返回所有标签")]),t._v(" "),e("li",[t._v("命令 "),e("code",[t._v("git log")]),t._v("（在 2.13 版 git 中，"),e("code",[t._v("git log")]),t._v(" 命令已改为自动启用 "),e("code",[t._v("--decorate")]),t._v(" 选项） 或 "),e("code",[t._v("git log --decorate")]),t._v(" 返回的标签与 SHA 位于同一行")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(748),alt:"多种方法查询标签"}})]),t._v(" "),e("h3",{attrs:{id:"删除标签"}},[t._v("删除标签")]),t._v(" "),e("p",[t._v("使用命令 "),e("code",[t._v("git tag -d <tag_name>")]),t._v("（选项 "),e("code",[t._v("-d")]),t._v(" 表示 delete 删除）删除指定的 git 标签 "),e("code",[t._v("<tag_name>")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(749),alt:"删除标签"}})]),t._v(" "),e("h2",{attrs:{id:"分支"}},[t._v("分支")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging",target:"_blank",rel:"noopener noreferrer"}},[t._v("git 分支 - 分支的新建与合并"),e("OutboundLink")],1),t._v("("),e("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6",target:"_blank",rel:"noopener noreferrer"}},[t._v("中译版"),e("OutboundLink")],1),t._v("）")]),t._v(" "),e("li",[e("a",{attrs:{href:"http://learngitbranching.js.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("了解 git 分支"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/using-branches",target:"_blank",rel:"noopener noreferrer"}},[t._v("git 分支教程"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("分支是允许我们"),e("strong",[t._v("对同一个项目进行不同操作")]),t._v("的隔离环境，分支常用来进行开发或对项目进行修正而不会影响到项目（因为更改是在分支上进行的）。")]),t._v(" "),e("h3",{attrs:{id:"创建分支"}},[t._v("创建分支")]),t._v(" "),e("p",[t._v("git 默认分支为 "),e("code",[t._v("MASTER")]),t._v("，可通过命令 "),e("code",[t._v("git branch new_branch")]),t._v(" 创建新分支，且指向最新的 commit。当需要在以前的 commit 处创建分支，可以在命令最后设置相应 SHA 即 "),e("code",[t._v("git branch new_branch SHA_num")])]),t._v(" "),e("p",[t._v("⚠️ 创建了新分支后，但是它还不是当前分支，需要使用命令 "),e("code",[t._v("git checkout branch_name")]),t._v(" 切换到该分支。")]),t._v(" "),e("p",[t._v("💡 使用切换分支命令同时添加选项 "),e("code",[t._v("-b")]),t._v(" 可以实现"),e("strong",[t._v("创建并切换到新分支")]),t._v(" "),e("code",[t._v("git checkout -b new_branch")])]),t._v(" "),e("h3",{attrs:{id:"查看分支"}},[t._v("查看分支")]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git branch")]),t._v(" 列出仓库所有的分支名称时，活跃分支名称旁边会显示一个"),e("strong",[t._v("星号")]),t._v("。此外Shell 提示符（括号中）也有显示活跃分支/当前分支。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(750),alt:"活跃分支"}})]),t._v(" "),e("p",[t._v("使用命令 "),e("code",[t._v("git log")]),t._v(" 或 "),e("code",[t._v("git log --decorate")]),t._v(" 查看日志时也会显示分支，其中 "),e("code",[t._v("HEAD")]),t._v(" 指向的是当前分支")]),t._v(" "),e("p",[e("img",{attrs:{src:v(751),alt:"日志中的分支"}})]),t._v(" "),e("p",[t._v("使用命令 "),e("code",[t._v("git log")]),t._v(" 并设置选项 "),e("code",[t._v("--graph")]),t._v(" 和 "),e("code",[t._v("--all")]),t._v(" 可以显示仓库中所有分支和 commit，并在最左侧使用符号进行可视化")]),t._v(" "),e("p",[e("img",{attrs:{src:v(752),alt:"可视化所有分支和 commit"}})]),t._v(" "),e("h3",{attrs:{id:"切换分支"}},[t._v("切换分支")]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git checkout branch_name")]),t._v(" 将 "),e("code",[t._v("HEAD")]),t._v(" 指针（"),e("code",[t._v("HEAD")]),t._v(" 表示当前分支，即活跃分支）切换到指定分支上，在进行 commit 时，该 commit 将添加到当前分支上。添加选项 "),e("code",[t._v("-b")]),t._v(" 可以同时实现创建并切换到新分支 "),e("code",[t._v("git checkout -b new_branch")])]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout -b footer master\n")])])]),e("p",[t._v("创建新的 "),e("code",[t._v("footer")]),t._v(" 分支并让此分支的"),e("strong",[t._v("起点位置")]),t._v("与 "),e("code",[t._v("master")]),t._v(" 分支的一样")]),t._v(" "),e("p",[t._v("⚠️ 执行该命令时会删除工作区中 git 所跟踪的所有文件和目录（因此应在切换分支前使用 "),e("code",[t._v("git status")]),t._v(" 查看是否有未提交的修改，应先把更新的文件提交到仓库）由于当前分支 git 跟踪的文件已存储在仓库中，因此什么也不会丢失。然后转到另一分支时，git 会提取该分支指向的 commit 所对应的所有文件和目录到工作区。")]),t._v(" "),e("p",[e("strong",[t._v("删除分支")]),t._v("\n命令 "),e("code",[t._v("git branch -d branch_name")]),t._v(" 删除特定的分支")]),t._v(" "),e("ul",[e("li",[t._v("无法删除当前所在的分支，需要切换到 master 分支，或者创建并切换到新的分支再删除当前分支")]),t._v(" "),e("li",[t._v("如果某个分支上有任何其他分支上都没有包含的 commit（也就是这个 commit 是要被删除的分支独有的），git 不会删除该分支。"),e("strong",[t._v("要强制删除，你需要使用大写的 "),e("code",[t._v("D")]),t._v(" 选项 "),e("code",[t._v("- git branch -D barnch_name")])])])]),t._v(" "),e("h3",{attrs:{id:"合并分支"}},[t._v("合并分支")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging#Basic-Merging",target:"_blank",rel:"noopener noreferrer"}},[t._v("分支合并"),e("OutboundLink")],1),t._v("|"),e("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6",target:"_blank",rel:"noopener noreferrer"}},[t._v("中"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-merge",target:"_blank",rel:"noopener noreferrer"}},[t._v("git-merge"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/git-merge",target:"_blank",rel:"noopener noreferrer"}},[t._v("git 合并"),e("OutboundLink")],1),t._v(" Atlassian 博客")])]),t._v(" "),e("p",[t._v("主题分支的作用是可以做出不影响 master 分支的更改。在主题分支上做出更改后，如果觉得不想要该分支上的更改，则可以删掉该分支；若决定要保留更改，则可以将该分支上的更改与其他分支上的更改合并。将分支组合到一起称为合并，git 中有两种类型的合并，即"),e("strong",[t._v("普通合并")]),t._v("和"),e("strong",[t._v("快进合并 fast forward")]),t._v("，合并分支时会提交 commit 并添加到检出分支/当前分支上。")]),t._v(" "),e("p",[t._v("命令 "),e("code",[t._v("git merge")]),t._v(" 用来合并 git 分支")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$ "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" merge "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("name-of-branch-to-merge-in"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),e("p",[t._v("发生合并时 git 查看分支的历史记录，并寻找两个分支的 commit 历史记录中都有的单个 commit 进行覆盖，而单个分支上更改的代码行进行合并（合并指的是另一个分支上的更改将出现在当前检出的分支上，即合并是将其他分支合并到当前（检出的）分支上，不是将两个分支合并到一个新的分支上），提交一个 commit 并添加到检出分支/当前分支（另一分支不影响），以记录合并操作")]),t._v(" "),e("p",[t._v("🎦 "),e("a",{attrs:{href:"https://www.jianguoyun.com/p/DfQmUG4QjNDGBxjN-uAD",target:"_blank",rel:"noopener noreferrer"}},[t._v("合并"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("如果在错误的分支上进行了合并，可使用命令 "),e("code",[t._v("git reset --hard HEAD^")]),t._v("撤消合并（字符 "),e("code",[t._v("^")]),t._v(" 表示相对 commit 引用，即父级 commit）")]),t._v(" "),e("h4",{attrs:{id:"快进合并"}},[t._v("快进合并")]),t._v(" "),e("p",[t._v("快进合并是将当前检出的分支向前移动，直到它指向与另一个分支（另一分支在 检出分支 前面）指向的 commit 一样为止。快进合并只需要将分支指针向前移动至另一分支（前方的）commit 即可")]),t._v(" "),e("p",[e("img",{attrs:{src:v(753),alt:"快进合并"}})]),t._v(" "),e("h4",{attrs:{id:"普通合并"}},[t._v("普通合并")]),t._v(" "),e("p",[t._v("普通合并是两个完全不一样的分支进行合并。在进行 commit 时，需要提供 commit 消息，代码编辑器打开时 git 已经提供了默认消息（也可以更改消息，但通常都会直接使用默认的合并 commit 消息），可直接关闭编辑器以确认使用该 commit 消息。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(754),alt:"普通合并"}})]),t._v(" "),e("h4",{attrs:{id:"合并冲突"}},[t._v("合并冲突")]),t._v(" "),e("p",[t._v("参考：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts",target:"_blank",rel:"noopener noreferrer"}},[t._v("遇到冲突时的分支合并"),e("OutboundLink")],1),t._v("（"),e("a",{attrs:{href:"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6",target:"_blank",rel:"noopener noreferrer"}},[t._v("中译版"),e("OutboundLink")],1),t._v("）")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://git-scm.com/docs/git-merge#_how_conflicts_are_presented",target:"_blank",rel:"noopener noreferrer"}},[t._v("冲突如何被显示"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("大部分情况下 git 将能够成功地合并分支，但相同的行在要合并的不同分支上做出了更改时，就会出现合并冲突。如果出现合并冲突，git 将在合并途中暂停并告诉你存在冲突。要解决文件中的冲突：")]),t._v(" "),e("ul",[e("li",[t._v("打开代码编辑器，找到合并冲突指示符所标注的行（一个文件可能在多个部分存在合并冲突，因此检查整个文件中的合并冲突指示符可搜索 "),e("code",[t._v("<<<")]),t._v(" 以查找到所有指示符）")]),t._v(" "),e("li",[t._v("决定保留哪些行，并删掉不需要的行（包括冲突指示符）")]),t._v(" "),e("li",[t._v("保存文件")]),t._v(" "),e("li",[t._v("暂存文件")]),t._v(" "),e("li",[t._v("提交 commit（推荐使用自动生成的合并 commit 消息）")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(755),alt:"合并冲突"}})]),t._v(" "),e("p",[t._v("git 尝试合并在两个分支上都更改了的文件 "),e("code",[t._v("index.html")]),t._v("，但是出现冲突。提示 "),e("code",[t._v('"Automatic merge failed; fix conflicts and then commit the result"')]),t._v(" 对冲突文件进行处理后再提交。也可以使用命令 "),e("code",[t._v("git status")]),t._v(" 查询冲突信息。")]),t._v(" "),e("p",[e("img",{attrs:{src:v(756),alt:"合并冲突指示符"}})]),t._v(" "),e("p",[t._v("使用代码编辑器查看冲突文件，其中具有多种合并冲突指示符")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("<<<<<<< HEAD")]),t._v(" 此行下方的所有内容（直到下个指示符）显示了当前分支上的行")]),t._v(" "),e("li",[e("code",[t._v("||||||| merged common ancestors")]),t._v(" 此行下方的所有内容（直到下个指示符）显示了"),e("strong",[t._v("原始行的内容")]),t._v("（即检出分支和合并的另一分支共有 commit （较前）中的版本）")]),t._v(" "),e("li",[e("code",[t._v("=======")]),t._v(" 表示原始行内容的结束位置，之后的所有行（直到下个指示符）是被合并的当前分支上的行的内容")]),t._v(" "),e("li",[e("code",[t._v(">>>>>>> heading-update")]),t._v(" 是要被合并的分支（此例中是 "),e("code",[t._v("heading-update")]),t._v(" 分支）上的行结束指示符")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(757),alt:"处理冲突"}})]),t._v(" "),e("p",[t._v("选择保留哪个标题（版本）后，删掉不需要的版本和所有包含合并冲突指示符的行，并保存文件。添加到暂存区，然后 commit（提交信息推荐用自动生成的合并 commit 消息）")])])}),[],!1,null,null,null);_.default=o.exports},725:function(t,_,v){t.exports=v.p+"assets/pdf/Git-terms-cheatsheet.pdf"},726:function(t,_,v){t.exports=v.p+"assets/pdf/ud123-git-keyterms.pdf"},727:function(t,_,v){t.exports=v.p+"assets/img/20191121231306446_13742.06af067c.png"},728:function(t,_,v){t.exports=v.p+"assets/img/20191121233723215_2414.0adfc59b.png"},729:function(t,_,v){t.exports=v.p+"assets/img/20191123114129288_29132.74d72de3.png"},730:function(t,_,v){t.exports=v.p+"assets/img/20191123115144238_16955.757f7da4.png"},731:function(t,_,v){t.exports=v.p+"assets/img/20191123120142305_5017.bdbee665.png"},732:function(t,_,v){t.exports=v.p+"assets/img/20191123163009784_14633.8a13dd4d.png"},733:function(t,_,v){t.exports=v.p+"assets/img/20191123165430232_5740.4cacf5bd.png"},734:function(t,_,v){t.exports=v.p+"assets/img/20191123200309211_1022.26f320f2.png"},735:function(t,_,v){t.exports=v.p+"assets/img/20191123203614812_13539.c2a5f592.png"},736:function(t,_,v){t.exports=v.p+"assets/img/20191123212454417_31704.642f7cc3.png"},737:function(t,_,v){t.exports=v.p+"assets/img/20191124103332766_8414.6b296b50.gif"},738:function(t,_,v){t.exports=v.p+"assets/img/20191124102942971_15126.0ad26aab.png"},739:function(t,_,v){t.exports=v.p+"assets/img/20191124103620980_30568.44a36281.png"},740:function(t,_,v){t.exports=v.p+"assets/img/20191124105254052_214.06303c52.png"},741:function(t,_,v){t.exports=v.p+"assets/img/20191124125623360_3929.9f01f191.png"},742:function(t,_,v){t.exports=v.p+"assets/img/20191124133550964_11673.6ad6c5aa.png"},743:function(t,_,v){t.exports=v.p+"assets/img/20191125232007335_276.d3ac5acb.png"},744:function(t,_,v){t.exports=v.p+"assets/img/20191125233006182_14015.09ef611e.png"},745:function(t,_,v){t.exports=v.p+"assets/img/20191124145801921_27239.2597c866.png"},746:function(t,_,v){t.exports=v.p+"assets/img/20191124155044992_28293.2b590c46.png"},747:function(t,_,v){t.exports=v.p+"assets/img/20191124170114997_8118.358b2d57.png"},748:function(t,_,v){t.exports=v.p+"assets/img/20191124174723785_10228.c54de7a4.png"},749:function(t,_,v){t.exports=v.p+"assets/img/20191124174948372_32376.02dfc1e4.png"},750:function(t,_,v){t.exports=v.p+"assets/img/20191124214539558_9509.64bdf640.png"},751:function(t,_,v){t.exports=v.p+"assets/img/20191124215936614_2725.d64ea409.png"},752:function(t,_,v){t.exports=v.p+"assets/img/20191125000547267_1280.bc89b838.png"},753:function(t,_,v){t.exports=v.p+"assets/img/20191125093413365_22843.1d699867.png"},754:function(t,_,v){t.exports=v.p+"assets/img/20191125094019574_16234.38d13c1f.png"},755:function(t,_,v){t.exports=v.p+"assets/img/20191125160452047_12583.a16f3dd6.png"},756:function(t,_,v){t.exports=v.p+"assets/img/20191125160732615_14810.1226eed4.png"},757:function(t,_,v){t.exports=v.p+"assets/img/20191125161309425_29506.7fff8222.gif"}}]);