(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{1e3:function(e,t,v){e.exports=v.p+"assets/img/20200511231925545_19129.4693bc13.png"},1377:function(e,t,v){"use strict";v.r(t);var r=v(18),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"事件循环"}},[e._v("事件循环")]),e._v(" "),r("p",[r("strong",[e._v("事件循环")]),e._v("是指 JavaScript 引擎在等待任务 -> 执行任务 -> 进入休眠状态等待更多任务，这几个状态之间转换的无限循环。")]),e._v(" "),r("p",[e._v("一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列，多个任务组成了一个队列，即所谓的「宏任务队列」（v8 术语）：")]),e._v(" "),r("p",[r("img",{attrs:{src:v(1e3),alt:"macrotask queue"}})]),e._v(" "),r("p",[e._v("微任务仅来自于代码，它们通常是由 promise 创建的，处理程序 "),r("code",[e._v(".then/catch/finally")]),e._v(" 或者使用 "),r("code",[e._v("await")]),e._v("  会生成成为微任务，还有一个特殊的函数 "),r("code",[e._v("queueMicrotask(func)")]),e._v("，它对 "),r("code",[e._v("func")]),e._v(" 进行排队，以在微任务队列中执行。"),r("strong",[e._v("每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作")]),e._v("。")]),e._v(" "),r("p",[e._v("事件循环的更详细的算法（尽管与 "),r("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model",target:"_blank",rel:"noopener noreferrer"}},[e._v("规范"),r("OutboundLink")],1),e._v(" 相比仍然是简化过的）：")]),e._v(" "),r("ol",[r("li",[e._v("从 "),r("strong",[e._v("宏任务")]),e._v(" 队列（例如 “script”）中出队（dequeue）并执行最早的任务。")]),e._v(" "),r("li",[e._v("执行所有 "),r("strong",[e._v("微任务")]),e._v("：\n"),r("ul",[r("li",[e._v("当微任务队列非空时：\n"),r("ul",[r("li",[e._v("出队（dequeue）并执行最早的微任务。")])])])])]),e._v(" "),r("li",[e._v("执行渲染，如果有。")]),e._v(" "),r("li",[e._v("如果宏任务队列为空，则休眠直到出现宏任务。")]),e._v(" "),r("li",[e._v("转到步骤 1。")])]),e._v(" "),r("p",[e._v("⚠️ 引擎执行任务时永远不会进行渲染 render，如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，无法处理用户事件，因此，在一定时间后浏览器会在整个页面抛出一个如「页面未响应」之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("使用零延迟的 "),r("code",[e._v("setTimeout(f)")]),e._v(" 安排（schedule）一个新的 "),r("strong",[e._v("宏任务")]),e._v("：它可被用于将繁重的计算任务拆分成多个部分，以使浏览器能够对用户事件作出反应，并在任务的各部分之间显示任务进度。此外，也被用于在事件处理程序中，将一个行为（action）安排（schedule）在事件被完全处理（冒泡完成）后。")])]),e._v(" "),r("li",[r("p",[e._v("使用 "),r("code",[e._v("queueMicrotask(f)")]),e._v(" 或 promise 处理程序的微任务队列安排一个新的 "),r("strong",[r("RouterLink",{attrs:{to:"/web/Frontend/JavaScript/语法基础/promise.html#微任务"}},[e._v("微任务")])],1),e._v("：在微任务之间没有 UI 或网络事件的处理：它们一个立即接一个地执行。所以，我们可以使用 "),r("code",[e._v("queueMicrotask")]),e._v(" 来在保持环境状态一致的情况下，异步地执行一个函数。")])])]),e._v(" "),r("p",[e._v("💡 对于不应该阻塞事件循环的耗时长的繁重计算任务，我们可以使用 "),r("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/workers.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Web Workers"),r("OutboundLink")],1),e._v("，它会在另一个并行线程中运行代码的方式。Web Workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环；它没有访问 DOM 的权限，因此它们对于同时使用多个 CPU 内核的计算非常有用。")])])}),[],!1,null,null,null);t.default=_.exports}}]);